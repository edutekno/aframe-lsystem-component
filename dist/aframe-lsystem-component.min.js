!function(t){function n(i){if(e[i])return e[i].t;var r=e[i]={i:i,o:!1,t:{}};return t[i].call(r.t,r,r.t,n),r.o=!0,r.t}var e={};n.s=t,n.c=e,n.d=function(t,e,i){n.u(t,e)||Object.defineProperty(t,e,{l:!1,h:!0,get:i})},n.n=function(t){var e=t&&t.m?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.u=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},n.p="",n(n._=0)}([function(t,n,e){"use strict";function i(t){let n=t.split(/(\w)\s*:\s*/).filter(t=>0!==t.length),e=[];for(var i=0;i<n.length;i+=2)e.push([n[i],n[i+1]]);return e}Object.defineProperty(n,"__esModule",{value:!0});var r=e(1);if("undefined"==typeof AFRAME)throw new Error("Component attempted to register before AFRAME was available.");var o=e(2);AFRAME.g("lsystem",{v:{S:{type:"string",default:"F"},C:{default:"F:FF",parse:t=>i(t).map(([t,n])=>[t,n.replace(/\s/g,"")])},A:{type:"string",parse:function(t){let n=new Map,e=i(t);for(let[t,i]of e)i=i.replace(/[\[\]]/g,"").split(","),n.set(t,i);return n}},P:{type:"int",default:1},angle:{default:90},k:{type:"string",default:"y",parse:function(t){if("x"===(t=t.toLowerCase()))return new THREE.O(1,0,0);if("y"===t)return new THREE.O(0,1,0);if("z"===t)return new THREE.O(0,0,1);throw new Error('translateAxis has to be a string: "x", "y" or "z"')}},I:{default:1},M:{default:!0},j:{type:"boolean",default:!0},F:{type:"boolean",default:!0}},init:function(){this.R=document.querySelector("a-scene");let t=this;this.T(),this.L=new THREE.O(1,0,0),this.B=new THREE.O(0,1,0),this.H=new THREE.O(0,0,1),this.$=new THREE.q,this.W=new THREE.q,this.D=new THREE.q,this.N=new THREE.q,this.J=new THREE.q,this.Y=new THREE.q,this.G=new THREE.q,this.$=new THREE.q,this.W=new THREE.q,this.D=new THREE.q,this.N=new THREE.q,this.J=new THREE.q,this.Y=new THREE.q,this.G=new THREE.q,this.U=1;let n=t.data.I;this.Z=0,this.lineWidth=5e-4,this.K=.125,this.V=new r.a({S:"F",C:{X:"F"},tt:{nt:()=>{t.it.et.multiply(t.D)},rt:()=>{t.it.et.multiply(t.N)},ot:()=>{t.it.et.multiply(t.Y)},st:()=>{t.it.et.multiply(t.J)},at:()=>{t.it.et.multiply(t.W)},ct:()=>{t.it.et.multiply(t.W)},ut:()=>{t.it.et.multiply(t.$)},lt:()=>{t.it.et.multiply(t.$)},ht:()=>{t.it.et.multiply(t.G)},ft:()=>{t.U*=n,t.it.scale.set(t.it.scale.x*=n,t.it.scale.y*=n,t.it.scale.z*=n),t.Z++},dt:()=>{t.U*=1/n,t.it.scale.set(t.it.scale.x*=1/n,t.it.scale.y*=1/n,t.it.scale.z*=1/n),t.Z=Math.max(0,t.Z-1)},pt:()=>{t.stack.push(t.it.clone())},bt:()=>{t.it=t.stack.pop()}}})},update:function(t){if(!1===this.data.j&&void 0!==this._t)for(let t of this._t.values())t.yt("mesh"),t.innerHTML="";if(0===Object.keys(t).length)this.xt(),this.gt(),this.vt();else{let n=!1;(t.S&&t.S!==this.data.S||t.P&&t.P!==this.data.P||t.C&&JSON.stringify(t.C)!==JSON.stringify(this.data.C))&&(this.xt(),n=!0),void 0!==t.A&&JSON.stringify(Array.from(t.A.entries()))!==JSON.stringify(Array.from(this.data.A.entries()))&&(this.gt(),n=!0),(n||t.angle&&t.angle!==this.data.angle)&&this.vt()}},wt:function(t,n){if(this.St.has(t))return this.St.get(t);n.Ct();let e;return this.data.k.At(this.L)?e=Math.abs(n.Et.min.x-n.Et.max.x):this.data.k.At(this.B)?e=Math.abs(n.Et.min.y-n.Et.max.y):this.data.k.At(this.H)&&(e=Math.abs(n.Et.min.z-n.Et.max.z)),this.St.set(t,e),e},T:function(){this.Pt=new o},kt:function(t){let n=this,e=n.it.et.clone(),i=n.it.position.clone(),r=n.it.scale.clone(),o=Math.min(this.Z,this.data.A.get(t).length-1),s=this.Ot.get(t+o);if(!1===this.data.j){let a=document.createElement("a-entity");a.setAttribute("mixin",s),a.addEventListener("loaded",t=>{let o=n.St.get(s);a.Mt.children[0].It(n.data.k,o*n.U/2),a.Mt.et.jt(e),a.Mt.position.jt(i),a.Mt.scale.jt(r)},{Ft:!0}),this._t.get(t+o).appendChild(a)}else{let n=this.Rt.get(t+o).clone();n.et.jt(e),n.position.jt(i),n.scale.jt(r),n.Tt=!1,n.Lt(),this.$t.get(t+o).Ht.Bt(n.Ht,n.matrix)}let a=this.St.get(s);this.it.It(this.data.k,a*this.U)},xt:function(){let t=this,n={S:this.data.S,C:this.data.C,P:this.data.P};return Date.now()-this.Pt.startTime>1e3&&(this.Pt.terminate(),this.T()),this.Pt.startTime=Date.now(),this.qt=new Promise((n,e)=>{this.Pt.onmessage=(e=>{t.V.Wt(e.data.result),n()})}),this.Pt.postMessage(n),this.qt},gt:function(){let t=this;this.Dt.innerHTML="",this._t=new Map,this.Ot=new Map;for(let[t,n]of this.data.A)for(let e=0;e<n.length;e++)this.Ot.set(t+e,n[e]);if(this.Rt=new Map,this.St=new Map,this.$t=new Map,this.zt=[],this.data.A&&0!==this.data.A.length)for(let n of this.data.A){let[e,i]=n;this.V.Nt(e,()=>{t.kt.bind(t,e)()});for(let n=0;n<i.length;n++){let r=n,o=i[r];t.zt.push(new Promise((n,i)=>{let s=document.createElement("a-entity");if(s.setAttribute("id",o+"-group-"+r+Math.floor(1e4*Math.random())),s.setAttribute("geometry","buffer",!1),s.setAttribute("mixin",o),s.addEventListener("loaded",function(i){let a=s.Jt("mesh").clone();s.Jt("mesh").Ht.Yt(),a.Ht=a.Ht.clone();let c=t.wt(o,a.Ht);if(!0===t.data.j){let n=t.data.k.clone().Gt(c*t.U/2);a.Ht.translate(n.x,n.y,n.z),t.Rt.set(e+r,a)}s.yt("mesh"),n()},{Ft:!0}),this._t.has(e+r)){let t=this._t.get(e+r);this._t.delete(e+r),this.Dt.removeChild(t)}this._t.set(e+r,s),this.Dt.appendChild(s)}))}}},vt:function(){Promise.all([...this.zt,this.qt]).then(()=>{if(this.it=new THREE.Ut,!0===this.data.j)for(let[t,n]of this.Rt)this.$t.set(t,new THREE.Zt(new THREE.Kt,n.Qt));this.stack=[];let t=this.data.angle;if(this.$.Vt(this.L,Math.PI/180*t),this.W.Vt(this.L,Math.PI/180*-t),this.D.Vt(this.B,Math.PI/180*t),this.N.Vt(this.B,Math.PI/180*-t),this.G.Vt(this.B,Math.PI/180*180),this.J.Vt(this.H,Math.PI/180*t),this.Y.Vt(this.H,Math.PI/180*-t),this.V.Xt(),!0===this.data.j)for(let t of this._t){let[n,e]=t;0===this.$t.get(n).Ht.tn.length?this.Dt.removeChild(e):(e.nn("mesh",this.$t.get(n)),e.setAttribute("mixin",this.Ot.get(n)))}})},remove:function(){},en:function(t){},pause:function(){},play:function(){}}),e(4)},function(t,n,e){"use strict";function i(t){var n=t[0].match(/(.+)<(.)/),e=t[0].match(/(.)>(.+)/);if(null===n&&null===e)return t;var i=void 0,r=t[1].in||t[1].rn?t[1]:{in:t[1]};return null!==n&&(i=n[2],r.on=n[1]),null!==e&&(i=e[1],r.sn=e[2]),[i,r]}function r(t){if("string"!=typeof t&&t instanceof String==!1)return t;for(var n=[],e=t,i=Array.isArray(e),r=0,e=i?e:e[Symbol.iterator]();;){var o;if(i){if(r>=e.length)break;o=e[r++]}else{if((r=e.next()).done)break;o=r.value}var s=o;n.push({an:s})}return n}function o(t,n){if(t.hasOwnProperty("successors"))for(var e=0;e<t.rn.length;e++)t.rn[e]=o(t.rn[e],n);else!1===t.hasOwnProperty("successor")&&(t={in:t});return n&&t.hasOwnProperty("successor")&&(t.in=r(t.in)),t}function s(t,n){return t[1]=o(t[1],n),t}function a(t){var n=t.S,e=void 0===n?"":n,o=t.C,a=t.tt,c=t.cn,u=void 0===c?"":c,l=t.un,h=void 0===l?"":l,f=t.ln,d=void 0===f||f,m=t.hn,p=void 0!==m&&m,b=t.fn,_=void 0!==b&&b,y=t.debug,x=void 0!==y&&y;return this.Wt=function(t){this.S=this.fn?r(t):t},this.dn=function(){return this.S},this.mn=function(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return"string"==typeof this.S?this.S:!0===t?this.S.reduce((t,n)=>{if(void 0===n.an)throw console.log("found:",n),new Error("L-Systems that use only objects as symbols (eg: {symbol: 'F', params: []}), cant use string symbols (eg. 'F')! Check if you always return objects in your productions and no strings.");return t+n.an},""):JSON.stringify(this.S)},this.pn=this.mn,this.bn=function(t,n){var e=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=[t,n];if(void 0===r)throw new Error("no production specified.");if(n.in&&n.rn)throw new Error('You can not have both a "successor" and a "successors" field in your production!');if(!0===this.ln&&(r=i(r,this.un)),r=s(r,this.fn),r[1]._n=void 0!==r[1].rn&&r[1].rn.every(t=>void 0!==t.weight),r[1]._n){r[1].yn=0;for(var o=r[1].rn,a=Array.isArray(o),c=0,o=a?o:o[Symbol.iterator]();;){var u;if(a){if(c>=o.length)break;u=o[c++]}else{if((c=o.next()).done)break;u=c.value}var l=u;r[1].yn+=l.weight}}var h=r[0];if(!0===e&&this.C.has(h)){var f=this.C.get(h),d=f.in,m=f.rn;d&&!m&&(f={rn:[f]}),f.rn.push(r[1]),this.C.set(h,f)}else this.C.set(h,r[1])},this.xn=function(t){if(void 0===t)throw new Error("no production specified.");this.gn();for(var n=Object.entries(t),e=Array.isArray(n),i=0,n=e?n:n[Symbol.iterator]();;){var r;if(e){if(i>=n.length)break;r=n[i++]}else{if((i=n.next()).done)break;r=i.value}var o=r,s=o[0],a=o[1];this.bn(s,a,!0)}},this.gn=function(){this.C=new Map},this.Nt=function(t,n){var e=[t,n];if(void 0===e)throw new Error("no final specified.");this.tt.set(e[0],e[1])},this.vn=function(t){if(void 0===t)throw new Error("no finals specified.");this.tt=new Map;for(var n in t)t.hasOwnProperty(n)&&this.Nt(n,t[n])},this.wn=function(t,n,e,i){var r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=void 0!==t.on||void 0!==t.sn,s=!1,a=!0;if(void 0!==t.Sn&&!1===t.Sn({index:n,Cn:this.S,An:e,En:i})?a=!1:o&&(void 0!==t.on&&void 0!==t.sn?a=this.match({direction:"left",match:t.on,index:n,cn:"[]"}).result&&this.match({direction:"right",match:t.sn,index:n,cn:"[]",un:h}).result:void 0!==t.on?a=this.match({direction:"left",match:t.on,index:n,cn:"[]"}).result:void 0!==t.sn&&(a=this.match({direction:"right",match:t.sn,index:n,cn:"[]"}).result)),!1===a)s=!1;else if(t.rn){var c,u;t._n&&(u=Math.random()*t.yn,c=0);for(var l=t.rn,f=Array.isArray(l),d=0,l=f?l:l[Symbol.iterator]();;){var m;if(f){if(d>=l.length)break;m=l[d++]}else{if((d=l.next()).done)break;m=d.value}var p=m;if(!(t._n&&(c+=p.weight)<u)){var b=this.wn(p,n,e,i,!0);if(void 0!==b&&!1!==b){s=b;break}}}}else s="function"==typeof t.in?t.in({index:n,Cn:this.S,An:e,En:i}):t.in;return s||(r?s:e)},this.Pn=function(){for(var t="string"==typeof this.S?"":[],n=0,e=this.S,i=Array.isArray(e),r=0,e=i?e:e[Symbol.iterator]();;){var o;if(i){if(r>=e.length)break;o=e[r++]}else{if((r=e.next()).done)break;o=r.value}var s=o,a=s.an||s,c=s.En||[],u=s;if(this.C.has(a)){var l=this.C.get(a);u=this.wn(l,n,s,c)}"string"==typeof t?t+=u:u instanceof Array?Array.prototype.push.apply(t,u):t.push(u),n++}return this.S=t,t},this.kn=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;this.P=t;for(var n=void 0,e=0;e<t;e++)n=this.Pn();return n},this.Xt=function(t){for(var n=0,e=this.S,i=Array.isArray(e),r=0,e=i?e:e[Symbol.iterator]();;){var o;if(i){if(r>=e.length)break;o=e[r++]}else{if((r=e.next()).done)break;o=r.value}var s=o,a=s;if("object"==typeof s&&s.an&&(a=s.an),this.tt.has(a)){var c=this.tt.get(a),u=typeof c;if("function"!==u)throw Error("'"+a+"' has an object for a final function. But it is __not a function__ but a "+u+"!");c({index:n,An:s},t)}n++}},this.match=function(t){var n=t.On,e=t.match,i=t.un,r=t.cn,o=t.index,s=t.direction,a=0,c=0;n=n||this.S,void 0===r&&(r=void 0!==this.cn?this.cn:[]),void 0===i&&(i=void 0!==this.un?this.un:[]);var u=[],l=void 0,h=void 0,f=void 0,d=void 0,m=void 0,p=void 0,b=void 0;if("right"===s){if(d=p=1,f=o+1,m=0,b=e.length,r.length>0){var _=r;l=_[0],h=_[1]}}else{if("left"!==s)throw Error(s,"is not a valid direction for matching.");if(d=p=-1,f=o-1,m=e.length-1,b=-1,r.length>0){var y=r;h=y[0],l=y[1]}}for(;f<n.length&&f>=0;f+=d){var x=n[f].an||n[f],g=e[m];if(x===g){if((0===a||c>0)&&(x===l?(c++,a++,m+=p):x===h?(c=Math.max(0,c-1),a=Math.max(0,a-1),0===c&&(m+=p)):(u.push(f),m+=p)),m===b)return{result:!0,In:u}}else if(x===l)a++,c>0&&c++;else if(x===h)a=Math.max(0,a-1),c>0&&(c=Math.max(0,c-1));else if((0===a||c>0&&g!==h)&&!1===i.includes(x))return{result:!1,In:u}}return{result:!1,In:u}},this.un=h,this.debug=x,this.cn=u,this.ln=d,this.hn=p,this.fn=_,this.Wt(e),this.gn(),o&&this.xn(o),a&&this.vn(a),this}a.Mn=function(t){return function(){for(var n=t,e=n.length,i=Math.random(),r=0;r<e;r++)if(i<=(r+1)/e)return n[r];console.error("Should have returned a result of the list, something is wrong here with the random numbers?.")}},a.jn=i,a.Fn=function(t){for(var n=t.replace(/\s+/g,"").split(/[\(\)]/),e=[],i=0;i<n.length-1;i+=2){var r=n[i+1].split(",").map(Number);e.push({an:n[i],En:r})}},a.Rn=function(t){return/\(.+\)/.test(t)},n.a=a},function(t,n,e){t.t=function(){return e(3)("/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lindenmayer__ = __webpack_require__(1);\n// Require instead of importScripts because we use webpack\n// with worker-loader for compiling source: https://github.com/webpack/worker-loader\n\nlet lsystem = new __WEBPACK_IMPORTED_MODULE_0_lindenmayer__[\"a\" /* default */]({});\nlet timeout = {};\n\nonmessage = function (e) {\n  // wait a few ms to start thread, to be able to cancel old tasks\n  clearTimeout(timeout);\n  timeout = setTimeout(function () {\n\n    lsystem.setAxiom(e.data.axiom);\n\n    lsystem.clearProductions();\n    for (let p of e.data.productions) {\n      lsystem.setProduction(p[0], p[1]);\n    }\n    lsystem.iterate(e.data.iterations);\n\n    postMessage({\n      result: lsystem.getString(),\n      initial: e.data\n    });\n  }, 20);\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// Get a list of productions that have identical initiators,\n// Output a single stochastic production. Probability per production\n// is defined by amount of input productions (4 => 25% each, 2 => 50% etc.)\n\n\n// These transformers get a classic ABOP snytax as input and return a standardized\n// production object in the form of ['F',\n// {\n//  successor:String/Iterable\n//  [alternatively]stochasticSuccessors: Iterable of standardized objects with mandatory weight fields,\n//  leftCtx: iterable/string,\n//  rightCtx: Iterable/String,\n//  condition: Function }]\n\nfunction transformClassicStochasticProductions(productions) {\n\n  return function transformedProduction() {\n    var resultList = productions; // the parser for productions shall create this list\n    var count = resultList.length;\n\n    var r = Math.random();\n    for (var i = 0; i < count; i++) {\n      var range = (i + 1) / count;\n      if (r <= range) return resultList[i];\n    }\n\n    console.error('Should have returned a result of the list, something is wrong here with the random numbers?.');\n  };\n};\n\n// TODO: Scaffold classic parametric and context sensitive stuff out of main file\n// And simply require it here, eg:\n// this.testClassicParametricSyntax = require(classicSyntax.testParametric)??\nfunction testClassicParametricSyntax(axiom) {\n  return (/\\(.+\\)/.test(axiom)\n  );\n};\n\n// transforms things like 'A(1,2,5)B(2.5)' to\n// [ {symbol: 'A', params: [1,2,5]}, {symbol: 'B', params:[25]} ]\n// strips spaces\nfunction transformClassicParametricAxiom(axiom) {\n\n  // Replace whitespaces, then split between square brackets.\n  var splitAxiom = axiom.replace(/\\s+/g, '').split(/[\\(\\)]/);\n  // console.log('parts:', splitAxiom)\n  var newAxiom = [];\n  // Construct new axiom by getting the params and symbol.\n  for (var i = 0; i < splitAxiom.length - 1; i += 2) {\n    var params = splitAxiom[i + 1].split(',').map(Number);\n    newAxiom.push({ symbol: splitAxiom[i], params: params });\n  }\n  // console.log('parsed axiom:', newAxiom)\n};\n\nfunction transformClassicCSProduction(p) {\n\n  // before continuing, check if classic syntax actually there\n  // example: p = ['A<B>C', 'Z']\n\n  // left should be ['A', 'B']\n  var left = p[0].match(/(.+)<(.)/);\n\n  // right should be ['B', 'C']\n  var right = p[0].match(/(.)>(.+)/);\n\n  // Not a CS-Production (no '<' or '>'),\n  //return original production.\n  if (left === null && right === null) {\n    return p;\n  }\n\n  var predecessor = void 0;\n  // create new production object _or_ use the one set by the user\n  var productionObject = p[1].successor || p[1].successors ? p[1] : { successor: p[1] };\n  if (left !== null) {\n    predecessor = left[2];\n    productionObject.leftCtx = left[1];\n  }\n  if (right !== null) {\n    predecessor = right[1];\n    productionObject.rightCtx = right[2];\n  }\n\n  return [predecessor, productionObject];\n};\n\nfunction stringToObjects(string) {\n  if (typeof string !== 'string' && string instanceof String === false) return string;\n  var transformed = [];\n  for (var _iterator = string, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var symbol = _ref;\n    transformed.push({ symbol });\n  }return transformed;\n}\n\n// transform p to {successor: p}\n// if applicable also transform strings into array of {symbol: String} objects\n// TODO: make more modular! dont have forceObjects in here\nfunction normalizeProductionRightSide(p, forceObjects) {\n\n  if (p.hasOwnProperty('successors')) {\n    for (var i = 0; i < p.successors.length; i++) {\n      p.successors[i] = normalizeProductionRightSide(p.successors[i], forceObjects);\n    }\n  } else if (p.hasOwnProperty('successor') === false) {\n    p = { successor: p };\n  }\n\n  if (forceObjects && p.hasOwnProperty('successor')) {\n    p.successor = stringToObjects(p.successor);\n  }\n\n  return p;\n}\n\nfunction normalizeProduction(p, forceObjects) {\n\n  p[1] = normalizeProductionRightSide(p[1], forceObjects);\n  return p;\n}\n\nfunction LSystem(_ref) {\n\tvar _ref$axiom = _ref.axiom,\n\t    axiom = _ref$axiom === undefined ? '' : _ref$axiom,\n\t    productions = _ref.productions,\n\t    finals = _ref.finals,\n\t    _ref$branchSymbols = _ref.branchSymbols,\n\t    branchSymbols = _ref$branchSymbols === undefined ? '' : _ref$branchSymbols,\n\t    _ref$ignoredSymbols = _ref.ignoredSymbols,\n\t    ignoredSymbols = _ref$ignoredSymbols === undefined ? '' : _ref$ignoredSymbols,\n\t    _ref$allowClassicSynt = _ref.allowClassicSyntax,\n\t    allowClassicSyntax = _ref$allowClassicSynt === undefined ? true : _ref$allowClassicSynt,\n\t    _ref$classicParametri = _ref.classicParametricSyntax,\n\t    classicParametricSyntax = _ref$classicParametri === undefined ? false : _ref$classicParametri,\n\t    _ref$forceObjects = _ref.forceObjects,\n\t    forceObjects = _ref$forceObjects === undefined ? false : _ref$forceObjects,\n\t    _ref$debug = _ref.debug,\n\t    debug = _ref$debug === undefined ? false : _ref$debug;\n\n\n\t// TODO: forceObject to be more intelligent based on other productions??\n\n\tthis.setAxiom = function (axiom) {\n\t\tthis.axiom = this.forceObjects ? stringToObjects(axiom) : axiom;\n\t};\n\n\tthis.getRaw = function () {\n\t\treturn this.axiom;\n\t};\n\n\t// if using objects in axioms, as used in parametric L-Systems\n\tthis.getString = function () {\n\t\tvar onlySymbols = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n\t\tif (typeof this.axiom === 'string') return this.axiom;\n\t\tif (onlySymbols === true) {\n\t\t\treturn this.axiom.reduce((prev, current) => {\n\t\t\t\tif (current.symbol === undefined) {\n\t\t\t\t\tconsole.log('found:', current);\n\t\t\t\t\tthrow new Error('L-Systems that use only objects as symbols (eg: {symbol: \\'F\\', params: []}), cant use string symbols (eg. \\'F\\')! Check if you always return objects in your productions and no strings.');\n\t\t\t\t}\n\t\t\t\treturn prev + current.symbol;\n\t\t\t}, '');\n\t\t} else {\n\t\t\treturn JSON.stringify(this.axiom);\n\t\t}\n\t};\n\n\tthis.getStringResult = this.getString;\n\n\tthis.setProduction = function (from, to) {\n\t\tvar allowAppendingMultiSuccessors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n\t\tvar newProduction = [from, to];\n\t\tif (newProduction === undefined) throw new Error('no production specified.');\n\n\t\tif (to.successor && to.successors) {\n\t\t\tthrow new Error('You can not have both a \"successor\" and a \"successors\" field in your production!');\n\t\t}\n\n\t\t// Apply production transformers and normalizations\n\t\tif (this.allowClassicSyntax === true) {\n\t\t\tnewProduction = transformClassicCSProduction(newProduction, this.ignoredSymbols);\n\t\t}\n\n\t\tnewProduction = normalizeProduction(newProduction, this.forceObjects);\n\n\t\t// check wether production is stochastic\n\t\tnewProduction[1].isStochastic = newProduction[1].successors !== undefined && newProduction[1].successors.every(successor => successor.weight !== undefined);\n\n\t\tif (newProduction[1].isStochastic) {\n\t\t\t// calculate weight sum\n\t\t\tnewProduction[1].weightSum = 0;\n\t\t\tfor (var _iterator = newProduction[1].successors, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n\t\t\t\tvar _ref2;\n\n\t\t\t\tif (_isArray) {\n\t\t\t\t\tif (_i >= _iterator.length) break;\n\t\t\t\t\t_ref2 = _iterator[_i++];\n\t\t\t\t} else {\n\t\t\t\t\t_i = _iterator.next();\n\t\t\t\t\tif (_i.done) break;\n\t\t\t\t\t_ref2 = _i.value;\n\t\t\t\t}\n\n\t\t\t\tvar s = _ref2;\n\n\t\t\t\tnewProduction[1].weightSum += s.weight;\n\t\t\t}\n\t\t}\n\n\t\tvar symbol = newProduction[0];\n\t\tif (allowAppendingMultiSuccessors === true && this.productions.has(symbol)) {\n\n\t\t\tvar existingProduction = this.productions.get(symbol);\n\t\t\tvar singleSuccessor = existingProduction.successor;\n\t\t\tvar multiSuccessors = existingProduction.successors;\n\n\t\t\tif (singleSuccessor && !multiSuccessors) {\n\t\t\t\t// replace existing prod with new obj and add previous successor as first elem\n\t\t\t\t// to new successors field.\n\t\t\t\texistingProduction = { successors: [existingProduction] };\n\t\t\t}\n\t\t\texistingProduction.successors.push(newProduction[1]);\n\t\t\tthis.productions.set(symbol, existingProduction);\n\t\t} else {\n\t\t\tthis.productions.set(symbol, newProduction[1]);\n\t\t}\n\t};\n\n\t// set multiple productions from name:value Object\n\t// TODO: ALLOW TUPLE/ARRAY\n\tthis.setProductions = function (newProductions) {\n\t\tif (newProductions === undefined) throw new Error('no production specified.');\n\t\tthis.clearProductions();\n\n\t\tfor (var _iterator2 = Object.entries(newProductions), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n\t\t\tvar _ref4;\n\n\t\t\tif (_isArray2) {\n\t\t\t\tif (_i2 >= _iterator2.length) break;\n\t\t\t\t_ref4 = _iterator2[_i2++];\n\t\t\t} else {\n\t\t\t\t_i2 = _iterator2.next();\n\t\t\t\tif (_i2.done) break;\n\t\t\t\t_ref4 = _i2.value;\n\t\t\t}\n\n\t\t\tvar _ref3 = _ref4;\n\t\t\tvar from = _ref3[0];\n\t\t\tvar to = _ref3[1];\n\n\t\t\tthis.setProduction(from, to, true);\n\t\t}\n\t};\n\n\tthis.clearProductions = function () {\n\t\tthis.productions = new Map();\n\t};\n\n\tthis.setFinal = function (symbol, final) {\n\t\tvar newFinal = [symbol, final];\n\t\tif (newFinal === undefined) {\n\t\t\tthrow new Error('no final specified.');\n\t\t}\n\t\tthis.finals.set(newFinal[0], newFinal[1]);\n\t};\n\n\t// set multiple finals from name:value Object\n\tthis.setFinals = function (newFinals) {\n\t\tif (newFinals === undefined) throw new Error('no finals specified.');\n\t\tthis.finals = new Map();\n\t\tfor (var symbol in newFinals) {\n\t\t\tif (newFinals.hasOwnProperty(symbol)) {\n\t\t\t\tthis.setFinal(symbol, newFinals[symbol]);\n\t\t\t}\n\t\t}\n\t};\n\n\t//var hasWeight = el => el.weight !== undefined;\n\tthis.getProductionResult = function (p, index, part, params) {\n\t\tvar recursive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n\n\t\tvar contextSensitive = p.leftCtx !== undefined || p.rightCtx !== undefined;\n\t\tvar conditional = p.condition !== undefined;\n\t\tvar stochastic = false;\n\t\tvar result = false;\n\t\tvar precheck = true;\n\n\t\t// Check if condition is true, only then continue to check left and right contexts\n\t\tif (conditional && p.condition({ index, currentAxiom: this.axiom, part, params }) === false) {\n\t\t\tprecheck = false;\n\t\t} else if (contextSensitive) {\n\t\t\tif (p.leftCtx !== undefined && p.rightCtx !== undefined) {\n\t\t\t\tprecheck = this.match({ direction: 'left', match: p.leftCtx, index: index, branchSymbols: '[]' }).result && this.match({ direction: 'right', match: p.rightCtx, index: index, branchSymbols: '[]', ignoredSymbols: ignoredSymbols }).result;\n\t\t\t} else if (p.leftCtx !== undefined) {\n\t\t\t\tprecheck = this.match({ direction: 'left', match: p.leftCtx, index: index, branchSymbols: '[]' }).result;\n\t\t\t} else if (p.rightCtx !== undefined) {\n\t\t\t\tprecheck = this.match({ direction: 'right', match: p.rightCtx, index: index, branchSymbols: '[]' }).result;\n\t\t\t}\n\t\t}\n\n\t\t// If conditions and context don't allow product, keep result = false\n\t\tif (precheck === false) {\n\t\t\tresult = false;\n\t\t}\n\n\t\t// If p has multiple successors\n\t\telse if (p.successors) {\n\t\t\t\t// This could be stochastic successors or multiple functions\n\t\t\t\t// Tread every element in the list as an individual production object\n\t\t\t\t// For stochastic productions (if all prods in the list have a 'weight' property)\n\t\t\t\t// Get a random number then pick a production from the list according to their weight\n\n\t\t\t\tvar currentWeight, threshWeight;\n\t\t\t\tif (p.isStochastic) {\n\t\t\t\t\tthreshWeight = Math.random() * p.weightSum;\n\t\t\t\t\tcurrentWeight = 0;\n\t\t\t\t}\n\t\t\t\t/*\n    go through the list and use\n    the first valid production in that list. (that returns true)\n    This assumes, it's a list of functions.\n    No recursion here: no successors inside successors.\n    */\n\t\t\t\tfor (var _iterator3 = p.successors, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n\t\t\t\t\tvar _ref5;\n\n\t\t\t\t\tif (_isArray3) {\n\t\t\t\t\t\tif (_i3 >= _iterator3.length) break;\n\t\t\t\t\t\t_ref5 = _iterator3[_i3++];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_i3 = _iterator3.next();\n\t\t\t\t\t\tif (_i3.done) break;\n\t\t\t\t\t\t_ref5 = _i3.value;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar _p = _ref5;\n\n\t\t\t\t\tif (p.isStochastic) {\n\t\t\t\t\t\tcurrentWeight += _p.weight;\n\t\t\t\t\t\tif (currentWeight < threshWeight) continue;\n\t\t\t\t\t}\n\t\t\t\t\t// If currentWeight >= thresWeight, a production is choosen stochastically\n\t\t\t\t\t// and evaluated recursively because it , kax also have rightCtx, leftCtx and condition to further inhibit production. This is not standard L-System behaviour though!\n\n\t\t\t\t\t// last true is for recursiv call\n\t\t\t\t\t// TODO: refactor getProductionResult to use an object\n\t\t\t\t\tvar _result = this.getProductionResult(_p, index, part, params, true);\n\t\t\t\t\t// console.log(part, p.successors);\n\t\t\t\t\t// console.log(result);\n\t\t\t\t\t// console.log(\"\\n\");\n\t\t\t\t\tif (_result !== undefined && _result !== false) {\n\t\t\t\t\t\tresult = _result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if successor is a function, execute function and append return value\n\t\t\telse if (typeof p.successor === 'function') {\n\n\t\t\t\t\tresult = p.successor({ index, currentAxiom: this.axiom, part, params });\n\t\t\t\t} else {\n\t\t\t\t\tresult = p.successor;\n\t\t\t\t}\n\n\t\tif (!result) {\n\t\t\t// Allow undefined or false results for recursive calls of this func\n\t\t\treturn recursive ? result : part;\n\t\t}\n\t\treturn result;\n\t};\n\n\tthis.applyProductions = function () {\n\t\t// a axiom can be a string or an array of objects that contain the key/value 'symbol'\n\t\tvar newAxiom = typeof this.axiom === 'string' ? '' : [];\n\t\tvar index = 0;\n\n\t\t// iterate all symbols/characters of the axiom and lookup according productions\n\t\tfor (var _iterator4 = this.axiom, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n\t\t\tvar _ref6;\n\n\t\t\tif (_isArray4) {\n\t\t\t\tif (_i4 >= _iterator4.length) break;\n\t\t\t\t_ref6 = _iterator4[_i4++];\n\t\t\t} else {\n\t\t\t\t_i4 = _iterator4.next();\n\t\t\t\tif (_i4.done) break;\n\t\t\t\t_ref6 = _i4.value;\n\t\t\t}\n\n\t\t\tvar part = _ref6;\n\n\n\t\t\t// Stuff for classic parametric L-Systems: get actual symbol and possible parameters\n\t\t\t// params will be given the production function, if applicable.\n\n\t\t\tvar symbol = part.symbol || part;\n\t\t\tvar params = part.params || [];\n\n\t\t\tvar result = part;\n\t\t\tif (this.productions.has(symbol)) {\n\t\t\t\tvar p = this.productions.get(symbol);\n\t\t\t\tresult = this.getProductionResult(p, index, part, params);\n\t\t\t}\n\n\t\t\t// Got result. Now add result to new axiom.\n\t\t\tif (typeof newAxiom === 'string') {\n\t\t\t\tnewAxiom += result;\n\t\t\t} else if (result instanceof Array) {\n\t\t\t\t// If result is an array, merge result into new axiom instead of pushing.\n\t\t\t\tArray.prototype.push.apply(newAxiom, result);\n\t\t\t} else {\n\t\t\t\tnewAxiom.push(result);\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\n\t\t// finally set new axiom and also return it for convenience.\n\t\tthis.axiom = newAxiom;\n\t\treturn newAxiom;\n\t};\n\n\tthis.iterate = function () {\n\t\tvar n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n\t\tthis.iterations = n;\n\t\tvar lastIteration = void 0;\n\t\tfor (var iteration = 0; iteration < n; iteration++) {\n\t\t\tlastIteration = this.applyProductions();\n\t\t}\n\t\treturn lastIteration;\n\t};\n\n\tthis.final = function (externalArg) {\n\t\tvar index = 0;\n\t\tfor (var _iterator5 = this.axiom, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n\t\t\tvar _ref7;\n\n\t\t\tif (_isArray5) {\n\t\t\t\tif (_i5 >= _iterator5.length) break;\n\t\t\t\t_ref7 = _iterator5[_i5++];\n\t\t\t} else {\n\t\t\t\t_i5 = _iterator5.next();\n\t\t\t\tif (_i5.done) break;\n\t\t\t\t_ref7 = _i5.value;\n\t\t\t}\n\n\t\t\tvar part = _ref7;\n\n\n\t\t\t// if we have objects for each symbol, (when using parametric L-Systems)\n\t\t\t// get actual identifiable symbol character\n\t\t\tvar symbol = part;\n\t\t\tif (typeof part === 'object' && part.symbol) symbol = part.symbol;\n\n\t\t\tif (this.finals.has(symbol)) {\n\t\t\t\tvar finalFunction = this.finals.get(symbol);\n\t\t\t\tvar typeOfFinalFunction = typeof finalFunction;\n\t\t\t\tif (typeOfFinalFunction !== 'function') {\n\t\t\t\t\tthrow Error('\\'' + symbol + '\\'' + ' has an object for a final function. But it is __not a function__ but a ' + typeOfFinalFunction + '!');\n\t\t\t\t}\n\t\t\t\t// execute symbols function\n\t\t\t\t// supply in first argument an details object with current index and part\n\t\t\t\t// and in the first argument inject the external argument (like a render target)\n\t\t\t\tfinalFunction({ index, part }, externalArg);\n\t\t\t} else {\n\t\t\t\t// symbol has no final function\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t};\n\n\t/*\n \thow to use match():\n  \t-----------------------\n \tIt is mainly a helper function for context sensitive productions.\n \tIf you use the classic syntax, it will by default be automatically transformed to proper\n \tJS-Syntax.\n \tHowerver, you can use the match helper function in your on productions:\n \n \tindex is the index of a production using `match`\n \teg. in a classic L-System\n \n \tLSYS = ABCDE\n \tB<C>DE -> 'Z'\n \n \tthe index of the `B<C>D -> 'Z'` production would be the index of C (which is 2) when the\n \tproduction would perform match(). so (if not using the ClassicLSystem class) you'd construction your context-sensitive production from C to Z like so:\n \n \tLSYS.setProduction('C', (index, axiom) => {\n \t\t(LSYS.match({index, match: 'B', direction: 'left'}) &&\n \t\t LSYS.match({index, match: 'DE', direction: 'right'}) ? 'Z' : 'C')\n \t})\n \n \tYou can just write match({index, ...} instead of match({index: index, ..}) because of new ES6 Object initialization, see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_6\n \t*/\n\n\tthis.match = function (_ref8) {\n\t\tvar axiom_ = _ref8.axiom_,\n\t\t    match = _ref8.match,\n\t\t    ignoredSymbols = _ref8.ignoredSymbols,\n\t\t    branchSymbols = _ref8.branchSymbols,\n\t\t    index = _ref8.index,\n\t\t    direction = _ref8.direction;\n\n\n\t\tvar branchCount = 0;\n\t\tvar explicitBranchCount = 0;\n\t\taxiom_ = axiom_ || this.axiom;\n\t\tif (branchSymbols === undefined) branchSymbols = this.branchSymbols !== undefined ? this.branchSymbols : [];\n\t\tif (ignoredSymbols === undefined) ignoredSymbols = this.ignoredSymbols !== undefined ? this.ignoredSymbols : [];\n\t\tvar returnMatchIndices = [];\n\n\t\tvar branchStart = void 0,\n\t\t    branchEnd = void 0,\n\t\t    axiomIndex = void 0,\n\t\t    loopIndexChange = void 0,\n\t\t    matchIndex = void 0,\n\t\t    matchIndexChange = void 0,\n\t\t    matchIndexOverflow = void 0;\n\t\t// set some variables depending on the direction to match\n\n\t\tif (direction === 'right') {\n\t\t\tloopIndexChange = matchIndexChange = +1;\n\t\t\taxiomIndex = index + 1;\n\t\t\tmatchIndex = 0;\n\t\t\tmatchIndexOverflow = match.length;\n\t\t\tif (branchSymbols.length > 0) {\n\t\t\t\t;\n\t\t\t\tvar _branchSymbols = branchSymbols;\n\t\t\t\tbranchStart = _branchSymbols[0];\n\t\t\t\tbranchEnd = _branchSymbols[1];\n\t\t\t}\n\t\t} else if (direction === 'left') {\n\t\t\tloopIndexChange = matchIndexChange = -1;\n\t\t\taxiomIndex = index - 1;\n\t\t\tmatchIndex = match.length - 1;\n\t\t\tmatchIndexOverflow = -1;\n\t\t\tif (branchSymbols.length > 0) {\n\t\t\t\t;\n\t\t\t\tvar _branchSymbols2 = branchSymbols;\n\t\t\t\tbranchEnd = _branchSymbols2[0];\n\t\t\t\tbranchStart = _branchSymbols2[1];\n\t\t\t}\n\t\t} else {\n\t\t\tthrow Error(direction, 'is not a valid direction for matching.');\n\t\t}\n\n\t\tfor (; axiomIndex < axiom_.length && axiomIndex >= 0; axiomIndex += loopIndexChange) {\n\n\t\t\tvar axiomSymbol = axiom_[axiomIndex].symbol || axiom_[axiomIndex];\n\t\t\tvar matchSymbol = match[matchIndex];\n\n\t\t\t// compare current symbol of axiom with current symbol of match\n\t\t\tif (axiomSymbol === matchSymbol) {\n\n\t\t\t\tif (branchCount === 0 || explicitBranchCount > 0) {\n\t\t\t\t\t// if its a match and previously NOT inside branch (branchCount===0) or in explicitly wanted branch (explicitBranchCount > 0)\n\n\t\t\t\t\t// if a bracket was explicitly stated in match axiom\n\t\t\t\t\tif (axiomSymbol === branchStart) {\n\t\t\t\t\t\texplicitBranchCount++;\n\t\t\t\t\t\tbranchCount++;\n\t\t\t\t\t\tmatchIndex += matchIndexChange;\n\t\t\t\t\t} else if (axiomSymbol === branchEnd) {\n\t\t\t\t\t\texplicitBranchCount = Math.max(0, explicitBranchCount - 1);\n\t\t\t\t\t\tbranchCount = Math.max(0, branchCount - 1);\n\t\t\t\t\t\t// only increase match if we are out of explicit branch\n\n\t\t\t\t\t\tif (explicitBranchCount === 0) {\n\n\t\t\t\t\t\t\tmatchIndex += matchIndexChange;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturnMatchIndices.push(axiomIndex);\n\t\t\t\t\t\tmatchIndex += matchIndexChange;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// overflowing matchIndices (matchIndex + 1 for right match, matchIndexEnd for left match )?\n\t\t\t\t// -> no more matches to do. return with true, as everything matched until here\n\t\t\t\t// *yay*\n\t\t\t\tif (matchIndex === matchIndexOverflow) {\n\t\t\t\t\treturn { result: true, matchIndices: returnMatchIndices };\n\t\t\t\t}\n\t\t\t} else if (axiomSymbol === branchStart) {\n\t\t\t\tbranchCount++;\n\t\t\t\tif (explicitBranchCount > 0) explicitBranchCount++;\n\t\t\t} else if (axiomSymbol === branchEnd) {\n\t\t\t\tbranchCount = Math.max(0, branchCount - 1);\n\t\t\t\tif (explicitBranchCount > 0) explicitBranchCount = Math.max(0, explicitBranchCount - 1);\n\t\t\t} else if ((branchCount === 0 || explicitBranchCount > 0 && matchSymbol !== branchEnd) && ignoredSymbols.includes(axiomSymbol) === false) {\n\t\t\t\t// not in branchSymbols/branch? or if in explicit branch, and not at the very end of\n\t\t\t\t// condition (at the ]), and symbol not in ignoredSymbols ? then false\n\t\t\t\treturn { result: false, matchIndices: returnMatchIndices };\n\t\t\t}\n\t\t}\n\n\t\treturn { result: false, matchIndices: returnMatchIndices };\n\t};\n\n\tthis.ignoredSymbols = ignoredSymbols;\n\tthis.debug = debug;\n\tthis.branchSymbols = branchSymbols;\n\tthis.allowClassicSyntax = allowClassicSyntax;\n\tthis.classicParametricSyntax = classicParametricSyntax;\n\tthis.forceObjects = forceObjects;\n\n\tthis.setAxiom(axiom);\n\n\tthis.clearProductions();\n\tif (productions) this.setProductions(productions);\n\tif (finals) this.setFinals(finals);\n\n\treturn this;\n}\n\n// Set classic syntax helpers to library scope to be used outside of library context\n// for users eg.\nLSystem.transformClassicStochasticProductions = transformClassicStochasticProductions;\nLSystem.transformClassicCSProduction = transformClassicCSProduction;\nLSystem.transformClassicParametricAxiom = transformClassicParametricAxiom;\nLSystem.testClassicParametricSyntax = testClassicParametricSyntax;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (LSystem);\n\n/***/ })\n/******/ ]);",null)}},function(t,n){var e=window.URL||window.webkitURL;t.t=function(t,n){try{try{var i;try{(i=new(window.Tn||window.WebKitBlobBuilder||window.Ln||window.Bn)).append(t),i=i.getBlob()}catch(n){i=new Blob([t])}return new Worker(e.createObjectURL(i))}catch(n){return new Worker("data:application/javascript,"+encodeURIComponent(t))}}catch(t){if(!n)throw Error("Inline worker is not supported");return new Worker(n)}}},function(t,n){AFRAME.Hn("a-lsystem",{$n:{qn:{S:"F",C:"F:F++F++F++F",P:3,angle:60}},Wn:{S:"lsystem.axiom",C:"lsystem.productions",A:"lsystem.segmentMixins",P:"lsystem.iterations",angle:"lsystem.angle"}})}]);